#pragma once

#include <iostream>
#include <assert.h>
#include "../../GlobalUtilities/GlobalUtilities.h"
#include "OpenHashTable.h"

namespace Ultrality
{
	namespace Memory
	{
		//A Dictionary of values sorted by their associated 32 bit int hash values
		//collisions are handled by probing for open node
		//hashes can be generated by any String or 32bit data Type (Key must = string || int, float)
		//does not dynamicaly allocate HashNodes, can dynamicaly allocate Values
		template<typename Key, typename Value>
		class ClosedHashTable
		{
		private:
			Allocator* m_parentAllocator;
		public:
			HashNode<Key, Value>* m_Dictionary;
			PoolAllocator* m_valueAllocator;
			unsigned __int32 m_tableSize = 0;
			unsigned __int32 m_usedTableSpace = 0;
			Value** m_dynamAllocValues;
			unsigned __int32 m_dynamAllocValuesRegistered = 0;

			//constructs a Dictionary with "arraySize" posible entries
			//set "supportValueAlloc" to true to alow for dynamic value allocations
			//its recommended that the "arraySize" is a prime number
			ClosedHashTable(const unsigned __int32& arraySize, bool supportValueAlloc, Allocator* allocator)
			{
				this->m_Dictionary = Memory::allocateArray<HashNode<Key, Value>>(allocator, arraySize);

				if (supportValueAlloc)
				{
					void* vp = allocator->allocate((sizeof(Value) * arraySize) + sizeof(PoolAllocator), __alignof(PoolAllocator));
					this->m_valueAllocator = new (vp) PoolAllocator(sizeof(Value), alignof(Value), (sizeof(Value) * arraySize), pointer_math::add(vp, sizeof(PoolAllocator)));
					
					this->m_dynamAllocValues = Memory::allocateArray<Value*>(allocator, arraySize);
				}
				else
				{
					this->m_valueAllocator = nullptr;
					this->m_dynamAllocValues = nullptr;
				}
				
				this->m_tableSize = arraySize;

				this->m_parentAllocator = allocator;
			}

			//inserts a new Node, must pass in pointer to a "Value" object
			//key must be a 32bit int, float or a string
			void Insert(Key&& key, Value* value)
			{
				if (this->m_usedTableSpace == this->m_tableSize)
				{
#ifdef DEBUG
					std::cout << "Table is full" << std::endl;
#endif // DEBUG
					return;
				}

				unsigned __int32 hash = GlobUtil::GlobalUtilities::Hasher(key);
				unsigned __int32 index = (hash % this->m_tableSize);

				if (this->m_Dictionary[index].m_Value == nullptr)
				{
					this->m_Dictionary[index].m_Value = value;
					this->m_Dictionary[index].m_Hash = hash;
#ifdef DEBUG
					this->m_Dictionary[index].m_Key = Memory::allocateNew<Key>(sizeof(Key), *this->m_parentAllocator, key);
#endif // DEBUG
					this->m_usedTableSpace++;
					return;
				}
				else
				{
					int i = 1;
					int checkIndex = 0;
					while(true)
					{
						checkIndex = ((index + (i * i)) % this->m_tableSize);
						if (this->m_Dictionary[checkIndex].m_value == nullptr)
						{					   
							this->m_Dictionary[checkIndex].m_Value = value;
							this->m_Dictionary[checkIndex].m_Hash = hash;
#ifdef DEBUG								   
							this->m_Dictionary[index].m_Key = Memory::allocateNew<Key>(sizeof(Key), *this->m_parentAllocator, key);
#endif // DEBUG
							this->m_usedTableSpace++;
							return;
						}
						checkIndex = ((index - (i * i)) % this->m_tableSize);
						if (this->m_Dictionary[checkIndex].m_Value == nullptr)
						{
							this->m_Dictionary[checkIndex].m_Value = value;
							this->m_Dictionary[checkIndex].m_Hash = hash;
#ifdef DEBUG								   
							this->m_Dictionary[index].m_Key = Memory::allocateNew<Key>(sizeof(Key), *this->m_parentAllocator, key);
#endif // DEBUG
							this->m_usedTableSpace++;
							return;
						}

						i++;
					}
				}
			}
			void InsertDynam(Key&& key, Value&& value)
			{
#ifdef DEBUG
				assert(this->m_valueAllocator);
#endif // DEBUG

				if (this->m_usedTableSpace == this->m_tableSize)
				{
#ifdef DEBUG
					std::cout << "Table is full" << std::endl;
#endif // DEBUG
					return;
				}

				unsigned __int32 hash = GlobUtil::GlobalUtilities::Hasher(key);
				unsigned __int32 index = (hash % this->m_tableSize);

				if (this->m_Dictionary[index].m_Value == nullptr)
				{
					this->m_Dictionary[index].m_Value = Memory::allocateNew<Value>(sizeof(Value), *this->m_valueAllocator, value);
					this->m_dynamAllocValues[index] = this->m_Dictionary[index].m_Value;
					this->m_dynamAllocValuesRegistered++;

					this->m_Dictionary[index].m_Hash = hash;
#ifdef DEBUG
					this->m_Dictionary[index].m_Key = Memory::allocateNew<Key>(sizeof(Key), *this->m_parentAllocator, key);
#endif // DEBUG
					this->m_usedTableSpace++;
					return;
				}
				else
				{
					int i = 1;
					int checkIndex = 0;
					while (true)
					{
						checkIndex = ((index + (i * i)) % this->m_tableSize);
						if (this->m_Dictionary[checkIndex].m_Value == nullptr)
						{
							this->m_Dictionary[checkIndex].m_Value = Memory::allocateNew<Value>(sizeof(Value), *this->m_valueAllocator, value);
							this->m_dynamAllocValues[checkIndex] = this->m_Dictionary[checkIndex].m_Value;
							this->m_dynamAllocValuesRegistered++;

							this->m_Dictionary[checkIndex].m_Hash = hash;
#ifdef DEBUG								   
							this->m_Dictionary[index].m_Key = Memory::allocateNew<Key>(sizeof(Key), *this->m_parentAllocator, key);
#endif // DEBUG
							this->m_usedTableSpace++;
							return;
						}
						checkIndex = ((index - (i * i)) % this->m_tableSize);
						if(this->m_Dictionary[checkIndex].m_Value == nullptr)
						{
							this->m_Dictionary[checkIndex].m_Value = Memory::allocateNew<Value>(sizeof(Value), *this->m_valueAllocator, value);
							this->m_dynamAllocValues[checkIndex] = this->m_Dictionary[checkIndex].m_Value;
							this->m_dynamAllocValuesRegistered++;

							this->m_Dictionary[checkIndex].m_Hash = hash;
#ifdef DEBUG								   
							this->m_Dictionary[index].m_Key = Memory::allocateNew<Key>(sizeof(Key), *this->m_parentAllocator, key);
#endif // DEBUG
							this->m_usedTableSpace++;
							return;
						}

						i++;
					}
				}
			}

			HashNode<Key, Value>* Search(const Key& key)
			{
				unsigned __int32 hash = GlobUtil::GlobalUtilities::Hasher(key);
				unsigned __int32 index = (hash % this->m_tableSize);

				if (this->m_Dictionary[index].m_Hash == hash)
				{
					return &this->m_Dictionary[index];
				}
				else
				{
					int i = 1;
					int checkIndex = 0;
					while (true)
					{
						checkIndex = ((index + (i * i)) % this->m_tableSize);
						if (this->m_Dictionary[checkIndex].m_Hash == hash)
						{
							return &this->m_Dictionary[checkIndex];
						}
						checkIndex = ((index - (i * i)) % this->m_tableSize);
						else if (this->m_Dictionary[checkIndex].m_Hash == hash)
						{
							return &this->m_Dictionary[checkIndex];
						}
						else if (i > this->m_TableSize)
						{
#ifdef DEBUG
							std::cout << "No such key in dictionary" << std::endl;
#endif // DEBUG

							return;
						}

						i++;
					}
				}
			}

			void RemoveNode(const Key& key)
			{
				unsigned __int32 hash = GlobUtil::GlobalUtilities::Hasher(key);
				unsigned __int32 index = (hash % this->m_tableSize);

				if (this->m_Dictionary[index].m_Hash == hash)
				{
					if (this->m_dynamAllocValues[index])
					{
						Memory::deallocateDelete<Value>(*this->m_valueAllocator, *this->m_dynamAllocValues[index]);
						this->m_dynamAllocValues[index] = nullptr;
						this->m_dynamAllocValuesRegistered--;
					}
					this->m_Dictionary[index].m_Hash = 0;
					this->m_Dictionary[index].m_Value = nullptr;
#ifdef DEBUG
					Memory::deallocateDelete<Key>(*this->m_parentAllocator, *this->m_Dictionary[index].m_Key);
					
					this->m_Dictionary[index].m_Key = nullptr;
#endif // DEBUG

				}
				else
				{
					int i = 1;
					int checkIndex = 0;
					while (true)
					{
						checkIndex = ((index + (i * i)) % this->m_tableSize);
						if (this->m_Dictionary[checkIndex].m_Hash == hash)
						{
							if (this->m_dynamAllocValues[checkIndex])
							{
								Memory::deallocateDelete<Value>(*this->m_valueAllocator, *this->m_dynamAllocValues[checkIndex]);
								this->m_dynamAllocValues[checkIndex] = nullptr;
								this->m_dynamAllocValuesRegistered--;
							}
							this->m_Dictionary[checkIndex].m_Hash = 0;
							this->m_Dictionary[checkIndex].m_Value = nullptr;
#ifdef DEBUG								   
							Memory::deallocateDelete<Key>(*this->m_parentAllocator, *this->m_Dictionary[checkIndex].m_Key);
							
							this->m_Dictionary[checkIndex].m_Key = nullptr;
#endif // DEBUG
						}
						checkIndex = ((index - (i * i)) % this->m_tableSize);
						else if (this->m_Dictionary[checkIndex].m_Hash == hash)
						{
							if (this->m_dynamAllocValues[checkIndex])
							{
								Memory::deallocateDelete<Value>(*this->m_valueAllocator, *this->m_dynamAllocValues[checkIndex]);
								this->m_dynamAllocValues[checkIndex] = nullptr;
								this->m_dynamAllocValuesRegistered--;
							}
							this->m_Dictionary[checkIndex].m_Hash = 0;
							this->m_Dictionary[checkIndex].m_Value = nullptr;
#ifdef DEBUG								   
							Memory::deallocateDelete<Key>(*this->m_parentAllocator, *this->m_Dictionary[checkIndex].m_Key);
							
							this->m_Dictionary[checkIndex].m_Key = nullptr;
#endif // DEBUG
						}
						else if (i > this->m_TableSize)
						{
#ifdef DEBUG
							std::cout << "No such key in dictionary" << std::endl;
#endif // DEBUG

							return;
						}

						i++;
					}
				}
			}

			void ClearDictionary()
			{
				this->DeleteDynamics();
				for (int i = 0; i < this->m_tableSize; i++)
				{
					if (this->m_Dictionary[i].m_Value)
					{
						this->m_Dictionary[i].m_Value = nullptr;
						this->m_Dictionary[i].m_Hash = 0;
#ifdef DEBUG
						Memory::deallocateDelete<Key>(*this->m_parentAllocator, *this->m_Dictionary[i].m_Key);

						this->m_Dictionary[i].m_Key = nullptr;
#endif // Debug
					}
				}
			}

			template<typename Key, typename Value>
			friend std::ostream& operator<<(std::ostream& stream, const ClosedHashTable<Key, Value>& hashTable)
			{
				if (hashTable.m_usedTableSpace == 0)
				{
					stream << "No entries in this Dictionary \n";
					return stream;
				}

				for (unsigned int i = 0; i < hashTable.m_tableSize; i++)
				{
					if (hashTable.m_Dictionary[i].m_Value)
						stream << hashTable.m_Dictionary[i] << "\n";
					else
						stream << "No Entry" << "\n";
				}

				return stream;
			}
			private:
				void DeleteDynamics()
				{
					for (int i = 0; i < this->m_dynamAllocValuesRegistered; i++)
					{
						if (this->m_dynamAllocValues[i])
						{
							Memory::deallocateDelete<Value>(*this->m_valueAllocator, *this->m_dynamAllocValues[i]);
							this->m_dynamAllocValues[i] = nullptr;
						}
					}
					this->m_dynamAllocValuesRegistered = 0;
				}
		};
	}
}